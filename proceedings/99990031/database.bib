@MISC{CVE-2016-1968,
	title = "{CVE}-2016-1968",
	howpublished = "Available from MITRE, {CVE-ID} {CVE}-2016-1968.",
	month=jan # "~20",
	author = {CVE},
	year = {2016},
	url={http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1968 },
	urldate={19 April 2015}
}


@inproceedings{Kroening2014,
	address = {Berlin, Heidelberg},
	author = {Kroening, Daniel and Tautschnig, Michael},
	doi = {10.1007/978-3-642-54862-8},
	file = {:Users/danlle/Dropbox/PhD/Papers/Kroening, Tautschnig - CBMC - C Bounded Model Checker - 2014.pdf:pdf},
	isbn = {978-3-642-54861-1},
	publisher = {Springer},
	booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
	title = {{CBMC C Bounded Model Checker}},
	url = {http://link.springer.com/10.1007/978-3-642-54862-8},
	volume = {8413},
	year = {2014}
}


@phdthesis{Acharya2009a,
	author = {Acharya, Mithun Puthige},
	file = {:Users/danlle/Dropbox/PhD/Papers/Acharya - Mining API Specifications from Source Code for Improving Software Reliability - 2009.pdf:pdf},
	title = {{Mining {API} Specifications from Source Code for Improving Software Reliability}},
	year = {2009},
	school = {North Carolina State University}
}

@inproceedings{VERIFY-2010:Automatic_generation_of_high_quality_test_sets_via_CBMC,
	author    = {Emanuele Di Rosa and Enrico Giunchiglia and Massimo Narizzano and Gabriele Palma and Alessandra Puddu},
	title     = {Automatic generation of high quality test sets via {CBMC}},
	booktitle = {VERIFY-2010. 6th International Verification Workshop},
	editor    = {Markus Aderhold and Serge Autexier and Heiko Mantel},
	series    = {EPiC Series in Computing},
	volume    = {3},
	pages     = {65-78},
	year      = {2012},
	publisher = {EasyChair},
	bibsource = {EasyChair, http://www.easychair.org},
	issn      = {2040-557X}}

@misc{fopen,
	author = {The IEEE and The Open Group},
	title = {The Open Group Base Specifications Issue 7: fopen},
	howpublished = "\url{http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html}",
	year = {2013}, 
	note = "[Online; accessed 17-April-2016]"
}

@misc{Brotli,
	author = {Google},
	title = {Brotli Commit 37a320d},
	year = {2016},
	publisher = {GitHub},
	howpublished = {\url{https://github.com/google/brotli/commit/37a320dd81db8d546cd24a45b4c61d87b45dcade}},
	commit = {37a320dd81db8d546cd24a45b4c61d87b45dcade}
}

@Inbook{Clarke2000,
	author="Clarke, Edmund
	and Grumberg, Orna
	and Jha, Somesh
	and Lu, Yuan
	and Veith, Helmut",
	chapter="Counterexample-Guided Abstraction Refinement ",
	title="Computer Aided Verification: 12th International Conference, CAV 2000, Chicago, IL, USA, July 15-19, 2000. Proceedings",
	year="2000",
	publisher="Springer",
	address="Berlin, Heidelberg",
	pages="154--169",
	isbn="978-3-540-45047-4",
	doi="10.1007/10722167_15",
	url="http://dx.doi.org/10.1007/10722167_15"
}



@MISC{BestAPITestingPractices,
	author = {Poley, Josh},
	title = {Best Practices: {API} Testing},
	month = feb,
	year = {2008},
	howpublished={\url{https://msdn.microsoft.com/en-us/library/cc300143.aspx}},
	note = "[Online; accessed 17-April-2016]"
}

@MISC{BestAPITestingPracticesHighCost,
	author = {Rychetnik, Devin A. 
		and Sohail, Syed},
	title = {Test Automation Code Review Guidelines},
	month = feb,
	year = {2008},
	howpublished={\url{https://msdn.microsoft.com/en-us/library/ff519670.aspx}},
	note = "[Online; accessed 17-April-2016]"
}


@MISC{BrotliDraft,
	author = {J. Alakuijala and 
	Z. Szabadka},
	title = {Brotli Compressed Data Format},
	month = apr,
	year = {2016},
	howpublished={\url{http://www.ietf.org/id/draft-alakuijala-brotli-09.txt}},
	note = "[Online; accessed 17-April-2016]"
}

@inproceedings{DBLP:conf/popl/CousotC77,
	author    = {Patrick Cousot and
	Radhia Cousot},
	title     = {Abstract Interpretation: {A} Unified Lattice Model for Static Analysis
	of Programs by Construction or Approximation of Fixpoints},
	booktitle = {Conference Record of the Fourth {ACM} Symposium on Principles of Programming
	Languages, Los Angeles, California, USA, January 1977},
	pages     = {238--252},
	year      = {1977},
	url       = {http://doi.acm.org/10.1145/512950.512973},
	doi       = {10.1145/512950.512973},
	timestamp = {Mon, 21 May 2012 16:19:51 +0200},
	biburl    = {http://dblp.uni-trier.de/rec/bib/conf/popl/CousotC77},
	bibsource = {dblp computer science bibliography, http://dblp.org}
}


@inproceedings{DBLP:conf/dsn/SheltonKD00,
	author    = {Charles P. Shelton and
	Philip Koopman and
	Kobey Devale},
	title     = {Robustness Testing of the {Microsoft} {Win32} {API}},
	booktitle = {2000 International Conference on Dependable Systems and Networks {(DSN}
	2000)},
	pages     = {261--270},
	year      = {2000},
	publisher = {{IEEE}},
	url       = {http://dx.doi.org/10.1109/ICDSN.2000.857548},
	doi       = {10.1109/ICDSN.2000.857548},
	timestamp = {Thu, 31 Mar 2016 15:55:04 +0200},
	biburl    = {http://dblp.uni-trier.de/rec/bib/conf/dsn/SheltonKD00},
	bibsource = {dblp computer science bibliography, http://dblp.org}
}

@inproceedings{ApiTestingPickingStrategy,
	author    = {Asha K. R. and
	Shwetha D. J.},
	title     = {{API} Testing: Picking the Right Strategy},
	booktitle = {Pacific Northwest Software Quality Conference 2015},
	pages     = {261--270},
	year      = {2015},
}


@MISC{HowToTest,
	author = {Michael Churchman},
	title = {{API} Testing: Why It Matters, and How To Do It},
	month = apr,
	year = {2014},
	howpublished={\url{https://blog.udemy.com/api-testing/}},
	note = "[Online; accessed 17-April-2016]"
}


@article{Pradel2012,
	abstract = {Concurrent, object-oriented programs often use thread-safe library classes. Existing techniques for testing a thread-safe class either rely on tests using the class, on formal specifications, or on both. Unfortunately, these techniques often are not fully automatic as they involve the user in analyzing the output. This paper presents an automatic testing technique that reveals concurrency bugs in supposedly thread-safe classes. The analysis requires as input only the class under test and reports only true positives. The key idea is to generate tests in which multiple threads call methods on a shared instance of the tested class. If a concurrent test exhibits an excep- tion or a deadlock that cannot be triggered in any linearized execution of the test, the analysis reports a thread safety violation. The approach is easily applicable, because it is independent of hand written tests and explicit specifications. The analysis finds 15 con- currency bugs in popular Java libraries, including two previously unknown bugs in the Java standard library.},
	author = {Pradel, Michael and Gross, Thomas R.},
	doi = {10.1145/2254064.2254126},
	file = {:Users/dan/Dropbox/PhD/Papers/Pradel, Gross - 2012 - Fully automatic and precise detection of thread safety violations.pdf:pdf},
	isbn = {9781450312059},
	issn = {0362-1340},
	journal = {Proceedings of the 33rd ACM SIGPLAN conference on Programming Language Design and Implementation - PLDI '12},
	keywords = {concurrent test generation,testing,thread safety},
	pages = {10},
	title = {{Fully automatic and precise detection of thread safety violations}},
	url = {http://dl.acm.org/citation.cfm?doid=2254064.2254126},
	year = {2012}
}

@article{Samak2015,
	abstract = {Subtle concurrency errors in multithreaded libraries that arise because of incorrect or inadequate synchronization are often difficult to pinpoint precisely using only static techniques. On the other hand, the effectiveness of dynamic race detectors is critically dependent on multithreaded test suites whose execution can be used to identify and trigger races. Usually, such multithreaded tests need to invoke a specific combination of methods with objects involved in the invocations being shared appropriately to expose a race. Without a priori knowledge of the race, construction of such tests can be challenging. In this paper, we present a lightweight and scalable technique for synthesizing precisely these kinds of tests. Given a multithreaded library and a sequential test suite, we describe a fully automated analysis that examines sequential execution traces, and produces as its output a concurrent client program that drives shared objects via library method calls to states conducive for triggering a race. Experimental results on a variety of well-tested Java libraries yield 101 synthesized multithreaded tests in less than four minutes. Analyzing the execution of these tests using an off-the-shelf race detector reveals 187 harmful races, including several previously unreported ones. Our implementation, named NARADA, and the results of our experiments are available at http://www.csa.iisc.ernet.in/{\~{}}sss/tools/narada.},
	author = {Samak, Malavika and Ramanathan, Murali Krishna and Jagannathan, Suresh},
	doi = {10.1145/2737924.2737998},
	file = {:Users/dan/Dropbox/PhD/Papers/Samak, Ramanathan, Jagannathan - 2015 - Synthesizing racy tests.pdf:pdf},
	isbn = {9781450334686},
	issn = {15232867},
	journal = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation - PLDI 2015},
	keywords = {applica-,concurrency,design,dynamic analysis,if a library is,nization,race detection,reliability,shown not to be,thread-safe,thus,verification},
	pages = {175--185},
	title = {{Synthesizing racy tests}},
	url = {http://dl.acm.org/citation.cfm?doid=2737924.2737998},
	year = {2015}
}


